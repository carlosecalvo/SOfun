% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Factor.R
\name{Factor}
\alias{Factor}
\alias{print.Factor}
\alias{RestoreFactor}
\title{Factor Vectors with Multiple Levels}
\usage{
Factor(invec, levels = list(), store = TRUE, ...)

\method{print}{Factor}(x, ...)

RestoreFactor(invec)
}
\arguments{
\item{invec}{A \code{vector} that needs to be factored.}

\item{levels}{A named \code{list} of the levels. The \code{name} is the
level and the values are what should be mapped to those levels.}

\item{store}{Logical. Should the input values be stored as an attribute?}

\item{\dots}{Additional arguments to \code{factor}.}

\item{x}{The object to be printed.}
}
\value{
A factored variable with \code{class} of \code{factor} and \code{Factor}, optionally
with an \code{attribute} of \code{"Input"} which stores the original input values.
}
\description{
\code{\link[base:factor]{base::factor()}} does not let you use duplicated levels nicely.
It results in an ugly warning message and you need to use \code{\link[base:droplevels]{base::droplevels()}}
to get the desired output. The "solution" is to first factor the vector, and
then use a named \code{list} with the \code{\link[base:levels]{base::levels()}} function. This function is
a wrapper around those steps.
}
\examples{

x <- c("Y", "Y", "Yes", "N", "No", "H")
Factor(x, list(Yes = c("Yes", "Y"), No = c("No", "N")))
Factor(x, list(Yes = c("Yes", "Y"), No = c("No", "N")), FALSE)
y <- Factor(x, list(No = c("No", "N"), Yes = c("Yes", "Y")), ordered = TRUE)
y

RestoreFactor(y)

}
\references{
\url{http://stackoverflow.com/a/19410249/1270695}
}
\seealso{
\code{\link[base:factor]{base::factor()}}, \code{\link[base:levels]{base::levels()}}
}
\author{
Ananda Mahto
}
